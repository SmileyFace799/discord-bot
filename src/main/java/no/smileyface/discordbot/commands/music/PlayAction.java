package no.smileyface.discordbot.commands.music;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.channel.middleman.GuildMessageChannel;
import net.dv8tion.jda.api.events.interaction.ModalInteractionEvent;
import net.dv8tion.jda.api.events.interaction.command.SlashCommandInteractionEvent;
import net.dv8tion.jda.api.events.interaction.component.ButtonInteractionEvent;
import net.dv8tion.jda.api.interactions.callbacks.IReplyCallback;
import net.dv8tion.jda.api.interactions.commands.OptionMapping;
import net.dv8tion.jda.api.interactions.commands.OptionType;
import net.dv8tion.jda.api.interactions.commands.build.Commands;
import net.dv8tion.jda.api.interactions.components.buttons.ButtonStyle;
import net.dv8tion.jda.api.interactions.components.text.TextInput;
import net.dv8tion.jda.api.interactions.components.text.TextInputStyle;
import net.dv8tion.jda.api.interactions.modals.ModalMapping;
import no.smileyface.discordbot.checks.InVoice;
import no.smileyface.discordbot.commands.SpotifyManager;
import no.smileyface.discordbot.model.MusicTrack;
import no.smileyface.discordbot.model.intermediary.MusicManager;
import no.smileyface.discordbotframework.InputRecord;
import no.smileyface.discordbotframework.entities.ActionCommand;
import no.smileyface.discordbotframework.entities.ActionModal;
import no.smileyface.discordbotframework.entities.BotAction;
import no.smileyface.discordbotframework.entities.ContextButton;
import no.smileyface.discordbotframework.misc.MultiTypeMap;
import org.apache.hc.core5.http.ParseException;
import se.michaelthelin.spotify.SpotifyApi;
import se.michaelthelin.spotify.exceptions.SpotifyWebApiException;
import se.michaelthelin.spotify.model_objects.specification.ArtistSimplified;
import se.michaelthelin.spotify.model_objects.specification.Paging;
import se.michaelthelin.spotify.model_objects.specification.PlaylistTrack;
import se.michaelthelin.spotify.model_objects.specification.Track;
import se.michaelthelin.spotify.model_objects.specification.TrackSimplified;

/**
 * Plays music.
 */
public class PlayAction extends BotAction<PlayAction.PlayKey> {
	private static final String YOUTUBE_SEARCH = "ytsearch:";
	private static final String YOUTUBE_SONG_FILTER = " \"auto-generated by YouTube\"";

	private static class PlayCommand extends ActionCommand<PlayKey> {
		public PlayCommand() {
			super(
					Commands
							.slash("play", "Plays a song")
							.setGuildOnly(true)
							.addOption(
									OptionType.STRING,
									PlayKey.INPUT.toString().toLowerCase(),
									"A search or URL for the song to play. "
											+ "Search is done through YouTube", true)
							.addOption(
									OptionType.BOOLEAN,
									PlayKey.SONG_SEARCH.toString().toLowerCase(),
									"If the YouTube search should search for songs only. "
											+ "Ignored if input is a URL  (Default: False)"),
					"p"
			);
		}

		@Override
		public MultiTypeMap<PlayKey> getSlashArgs(SlashCommandInteractionEvent event) {
			MultiTypeMap<PlayKey> args = new MultiTypeMap<>();
			args.put(PlayKey.INPUT, event.getOption(
					PlayKey.INPUT.str(),
					OptionMapping::getAsString)
			);
			args.put(PlayKey.SONG_SEARCH, event.getOption(
					PlayKey.SONG_SEARCH.str(),
					false,
					OptionMapping::getAsBoolean
			));
			return args;
		}
	}

	private static class PlayModal extends ActionModal<PlayKey> {
		public PlayModal() {
			super("queueSongModal", "Queue a song / video / playlist", List.of(
					TextInput.create(
							PlayKey.INPUT.str(),
							"URL / YouTube search query",
							TextInputStyle.SHORT
					).build(),
					TextInput.create(
									PlayKey.SONG_SEARCH.str(),
									"Search only for songs? (Default: False)",
									TextInputStyle.SHORT
							).setPlaceholder("y/n, yes/no, true/false (case-insensitive)")
							.setRequired(false)
							.build()
			));
		}

		@Override
		public MultiTypeMap<PlayKey> getModalArgs(ModalInteractionEvent event) {
			MultiTypeMap<PlayKey> args = new MultiTypeMap<>();

			args.put(PlayKey.INPUT, Objects.requireNonNull(
					event.getValue(PlayKey.INPUT.str())
			).getAsString());

			ModalMapping songSearch = event.getValue(PlayKey.SONG_SEARCH.str());
			args.put(PlayKey.SONG_SEARCH, songSearch != null
					&& Stream.of("y", "yes", "true")
					.anyMatch(yes -> yes.equalsIgnoreCase(songSearch.getAsString()))
			);

			return args;
		}
	}

	/**
	 * Button to undo queuing tracks action.
	 */
	public class UndoContextButton extends ContextButton<PlayKey> {
		private final List<MusicTrack> tracksToUndo;

		protected UndoContextButton() {
			super(PlayAction.this, ButtonStyle.PRIMARY, "Undo");
			this.tracksToUndo = new ArrayList<>();
		}

		public void addTracksToUndo(List<MusicTrack> tracks) {
			tracksToUndo.addAll(tracks);
		}

		public void addTracksToUndo(MusicTrack track) {
			tracksToUndo.add(track);
		}

		@Override
		public void clicked(
				ButtonInteractionEvent event,
				MultiTypeMap<PlayKey> args,
				InputRecord inputs
		) {
			try {
				MusicManager.getInstance().remove(
						tracksToUndo,
						Objects.requireNonNull(event.getGuild())
				);
				event.reply("Removed the queued song" + (tracksToUndo.size() == 1 ? "" : "s"))
						.setEphemeral(true)
						.queue();
			} catch (NullPointerException npe) {
				event.reply("Music has already stopped")
						.setEphemeral(true)
						.queue();
			}
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (o == null || getClass() != o.getClass()) {
				return false;
			}
			if (!super.equals(o)) {
				return false;
			}
			UndoContextButton that = (UndoContextButton) o;
			return Objects.equals(tracksToUndo, that.tracksToUndo);
		}

		@Override
		public int hashCode() {
			return Objects.hash(super.hashCode(), tracksToUndo);
		}
	}

	/**
	 * Makes the play action.
	 */
	public PlayAction() {
		super(new PlayCommand(), new PlayModal(), new InVoice());
	}

	private static String getYouTubeSearch(String name, ArtistSimplified[] artists) {
		return YOUTUBE_SEARCH
				+ name
				+ " " + (artists == null ? "" : String.join(" ",
				Arrays.stream(artists)
						.map(ArtistSimplified::getName)
						.toList()))
				+ " " + YOUTUBE_SONG_FILTER;
	}

	private static String getSpotifyTrackSearch(SpotifyApi api, String spotifyLink)
			throws IOException, SpotifyWebApiException, ParseException {
		Track track = api
				.getTrack(spotifyLink.split("track/")[1].split("\\?")[0])
				.build()
				.execute();
		return getYouTubeSearch(track.getName(), track.getArtists());
	}

	private static List<String> getSpotifyAlbumSearches(SpotifyApi api, String spotifyLink)
			throws IOException, SpotifyWebApiException, ParseException {
		List<String> links = new ArrayList<>();
		String next = spotifyLink.split("album/")[1].split("\\?")[0];
		int offset = 0;
		int limit = 50;
		while (next != null) {
			Paging<TrackSimplified> page = api
					.getAlbumsTracks(next)
					.offset(offset)
					.limit(limit)
					.build()
					.execute();
			String nextUrl = page.getNext();
			next = nextUrl == null ? null
					: nextUrl.split("albums/")[1].split("/")[0];
			if (next != null) {
				offset = Integer.parseInt(nextUrl.split(
						"offset=")[1].split("&")[0]);
				limit = Integer.parseInt(nextUrl.split(
						"limit=")[1].split("&")[0]);
			}
			links.addAll(Arrays.stream(page
							.getItems())
					.map(track -> getYouTubeSearch(track.getName(), track.getArtists()))
					.toList()
			);
		}
		return links;
	}

	private static List<String> getSpotifyPlaylistSearches(SpotifyApi api, String spotifyLink)
			throws IOException, SpotifyWebApiException, ParseException {
		List<String> links = new ArrayList<>();
		String next = spotifyLink.split("playlist/")[1].split("\\?")[0];
		int offset = 0;
		int limit = 100;
		while (next != null) {
			Paging<PlaylistTrack> page = api.getPlaylistsItems(next)
					.offset(offset)
					.limit(limit)
					.build()
					.execute();
			String nextUrl = page.getNext();
			next = nextUrl == null ? null
					: nextUrl.split("playlists/")[1].split("/")[0];
			if (next != null) {
				offset = Integer.parseInt(nextUrl.split(
						"offset=")[1].split("&")[0]);
				limit = Integer.parseInt(nextUrl.split(
						"limit=")[1].split("&")[0]);
			}
			links.addAll(Arrays
					.stream(page.getItems())
					.map(track -> {
						String youtubeSearch;
						try {
							Track fullTrack =
									api.getTrack(track.getTrack().getId()).build().execute();
							youtubeSearch = getYouTubeSearch(
									fullTrack.getName(), fullTrack.getArtists());
						} catch (IOException | SpotifyWebApiException | ParseException e) {
							youtubeSearch = getYouTubeSearch(track.getTrack().getName(), null);
						}
						return youtubeSearch;
					}).toList()
			);
		}
		return links;
	}

	private static List<String> spotifyToYouTubeSearch(String spotifyLink) {
		List<String> links = new ArrayList<>();
		try {
			SpotifyApi api = SpotifyManager.getInstance().getApi();
			if (api == null) {
				throw new IllegalStateException("Spotify is not supported");
			}
			if (spotifyLink.contains("track/")) {
				links.add(getSpotifyTrackSearch(api, spotifyLink));
			} else if (spotifyLink.contains("album/")) {
				links.addAll(getSpotifyAlbumSearches(api, spotifyLink));
			} else if (spotifyLink.contains("playlist/")) {
				links.addAll(getSpotifyPlaylistSearches(api, spotifyLink));
			}
		} catch (IOException | SpotifyWebApiException | ParseException e) {
			throw new IllegalStateException("Spotify error: "
					+ e.getMessage());
		}
		return links;
	}

	private static List<String> getIdentifiers(String[] links) {
		List<String> identifiers = new ArrayList<>();
		for (String link : links) {
			if (
					link.toLowerCase().contains("youtube.com")
							&& link.contains("v=")
							&& link.contains("list=")
			) {
				//If it's a YouTube video in a playlist, only play that video
				identifiers.add("https://www.youtube.com/watch?v="
						+ link.split("v=")[1].split("&")[0]);
			} else if (link.contains("open.spotify.com")) {
				identifiers.addAll(spotifyToYouTubeSearch(link));
			} else {
				identifiers.add(link);
			}
		}
		return identifiers;
	}

	@Override
	protected void execute(
			IReplyCallback event,
			MultiTypeMap<PlayKey> args,
			InputRecord inputs
	) {
		event.deferReply().setEphemeral(true).queue();
		Member author = Objects.requireNonNull(event.getMember());
		String input = args.get(PlayKey.INPUT, String.class);
		boolean songSearch = args.get(PlayKey.SONG_SEARCH, Boolean.class);
		List<String> identifiers = new ArrayList<>();

		String[] splitInput = input.replace("  ", " ").split(" ");
		if (Arrays.stream(splitInput).allMatch(identifier ->
				identifier.startsWith("https://") || identifier.startsWith("http://"))
		) {
			identifiers.addAll(getIdentifiers(splitInput));
		} else {
			String search = YOUTUBE_SEARCH + input;

			if (songSearch) {
				search += YOUTUBE_SONG_FILTER;
			}
			identifiers.add(search);
		}

		MusicManager.getInstance().createPlayerIfNotExists(
				Objects.requireNonNull(Objects.requireNonNull(
						author.getVoiceState()
				).getChannel()),
				(GuildMessageChannel) event.getMessageChannel(),
				inputs,
				null
		);
		if (identifiers.size() == 1) {
			MusicManager.getInstance().queue(
					identifiers.getFirst(),
					new UndoContextButton(),
					author,
					event.getHook()
			);
		} else {
			MusicManager.getInstance().queueMultiple(
					identifiers,
					new UndoContextButton(),
					author,
					event.getHook()
			);
		}
	}

	/**
	 * Keys for args map.
	 */
	public enum PlayKey implements ArgKey {
		INPUT,
		SONG_SEARCH
	}
}
